# Import necessary components from FastAPI, Pydantic for data validation, and SQLAlchemy for database operations
from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy import Column, Integer, String, create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import Session, sessionmaker
from fastapi.middleware.cors import CORSMiddleware

# Define the database connection string
# Using SQLite with a local file named messages.db
DATABASE_URL = "sqlite:///./messages.db"

# SQLAlchemy setup
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

app = FastAPI()
# Allow CORS for the frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class MessageModel(Base):
    __tablename__ = "messages"
    id = Column(Integer, primary_key=True, index=True)
    content = Column(String)
    order = Column(Integer)
    
# Create all tables in the database
Base.metadata.create_all(bind=engine)

# Message model for responses - represents how messages are returned from the API and stored in the DB.
class Message(BaseModel):
    id: int          # Unique identifier for the message
    content: str     # The text content of the message
    order: int       # The order/position of the message
    
    class Config:
        from_attributes = True
  
# No ID field as it will be generated by the database  
class MessageCreate(BaseModel):
    content: str
    order: int

# MessageUpdate model for request validation when updating messages
# Both fields are optional, allowing partial updates
class MessageUpdate(BaseModel):
    content: str | None = None
    order: int | None = None

# Dependency function to create and manage database sessions
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
        
# GET endpoint to retrieve all messages
@app.get("/messages", response_model=list[Message])
def get_messages(db: Session = Depends(get_db)):
    messages = db.query(MessageModel).all()
    return messages

# POST endpoint to create a new message
@app.post("/messages", response_model=Message)
def create_message(message: MessageCreate, db: Session = Depends(get_db)):
    db_message = MessageModel(**message.model_dump())
    db.add(db_message)
    db.commit()
    db.refresh(db_message)
    return db_message

# DELETE endpoint to remove a message by ID
@app.delete("/messages/{message_id}")
def delete_message(message_id: int, db: Session = Depends(get_db)):
    db_message = db.query(MessageModel).filter(MessageModel.id == message_id).first()
    if db_message is None:
        raise HTTPException(status_code=404, detail="Message not found")
    db.delete(db_message)
    db.commit()
    return db_message

# PUT endpoint to update an existing message by ID
@app.put("/messages/{message_id}", response_model=Message)
def update_message(message_id: int, message: MessageUpdate, db: Session = Depends(get_db)):
    db_message = db.query(MessageModel).filter(MessageModel.id == message_id).first()
    if db_message is None:
        raise HTTPException(status_code=404, detail="Message not found")
    for key, value in message.model_dump().items():
        setattr(db_message, key, value)
    db.commit()
    db.refresh(db_message)
    return db_message